<!DOCTYPE html
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<!-- Bootstrap CSS -->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
</head>

<body>
    <header>
    <div class="navbar navbar-dark bg-dark box-shadow"
    <div class="container">
        <div class="row">
            <div class="container d-flex justify-content-between">
                <ul class="nav align-items-center">
            <li class="nav-item">
                <strong><a class="navbar-brand active" href="/">Home</a></strong>
            </li>
            <li class="nav-item">
                <strong><a class="navbar-brand" href="/blog/">Blog</a></strong>
            </li>
        </ul>
            </div>
        </div>
    </div>
    </div>
    </header>

    <div class="container">

    
<div class='container'>
    <section class="post">
        <article>
            <p>Recently, I have implemented Python bindings for a number of software libraries
I work on. For this, I have used the excellent <a href="https://github.com/pybind/pybind11">pybind11</a>, which makes it easy to
provide bindings for basic C++ functions and classes. Generating bindings for
functions and classes looks like this:</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#a7adba;">// bindings for a function
</span><span style="background-color:#eff1f5;color:#4f5b66;">m.</span><span style="background-color:#eff1f5;color:#bf616a;">def</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">add</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;, &amp;add, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">A function which adds two numbers</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#a7adba;">// bindings for a class
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Pet&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">Pet</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;).</span><span style="background-color:#eff1f5;color:#bf616a;">def</span><span style="background-color:#eff1f5;color:#4f5b66;">(py::</span><span style="background-color:#eff1f5;color:#bf616a;">init</span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">const</span><span style="background-color:#eff1f5;color:#4f5b66;"> std::string &amp;&gt;())
</span></pre>
<p>While writing these bindings, I ran into two problems for two different
projects, and in both cases they lead to lengthy binding definitions with a lot
of repeated code.</p>
<em></em><h2 id="problem-1">Problem 1: Many aggregate data types {#problem-1-many-aggregate-data-types}</h2>
<p>One project had a lot of aggregate data types, and generating bindings for them
required repeating their fields three times: in the definition, when exposing
the constructor to Python, and for defining the accessors to the fields. This
will inevitably lead to frustrating maintenance work as fields get added and
removed. In my case, these data types described packets that would be sent over
a network connection, and they would look something like this:</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#b48ead;">struct </span><span style="background-color:#eff1f5;color:#4f5b66;">SomePacket {
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#b48ead;">static constexpr auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> desc = descriptor::some_packet;
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#4f5b66;">int32_t id;
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;"> some_payload;
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#a7adba;">// ... more fields
</span><span style="background-color:#eff1f5;color:#4f5b66;">};
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#b48ead;">struct </span><span style="background-color:#eff1f5;color:#4f5b66;">AnotherPacket {
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#b48ead;">static constexpr auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> desc = descriptor::another_packet;
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#4f5b66;">int32_t id;
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#4f5b66;">std::vector&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt; another_payload;
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#a7adba;">// ... more fields
</span><span style="background-color:#eff1f5;color:#4f5b66;">};
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#a7adba;">// ... many more
</span></pre>
<p>Of course in reality packets typically have more than two fields. The binding
code would look like this:</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;SomePacket&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">some_packet</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;)
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">.</span><span style="background-color:#eff1f5;color:#bf616a;">def</span><span style="background-color:#eff1f5;color:#4f5b66;">(py::</span><span style="background-color:#eff1f5;color:#bf616a;">init</span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;int32_t, </span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;())
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">.</span><span style="background-color:#eff1f5;color:#bf616a;">def_readwrite</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">id</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;, &amp;SomePacket::id)
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">.</span><span style="background-color:#eff1f5;color:#bf616a;">def_readwrite</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">some_payload</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;, &amp;SomePacket::some_payload)
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">.</span><span style="background-color:#eff1f5;color:#bf616a;">def_readwrite</span><span style="background-color:#eff1f5;color:#4f5b66;">(...);
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;AnotherPacket&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">another_packet</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;)
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">.</span><span style="background-color:#eff1f5;color:#bf616a;">def</span><span style="background-color:#eff1f5;color:#4f5b66;">(py::</span><span style="background-color:#eff1f5;color:#bf616a;">init</span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;int32_t, std::vector&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;())
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">.</span><span style="background-color:#eff1f5;color:#bf616a;">def_readwrite</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">id</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;, &amp;AnotherPacket::id)
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">.</span><span style="background-color:#eff1f5;color:#bf616a;">def_readwrite</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">another_payload</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;, &amp;AnotherPacket::another_payload)
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">.</span><span style="background-color:#eff1f5;color:#bf616a;">def_readwrite</span><span style="background-color:#eff1f5;color:#4f5b66;">(...);
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#a7adba;">// ... many more
</span></pre><em></em><h2 id="problem-2">Problem 2: Templates {#problem-2-templates}</h2>
<p>A second problem is when you want to generate bindings to templates. In another
project, I had many classes and functions that were generic over two parameters:
one integer that defines the dimension of the object or problem, and one type
parameter representing the scalar type that is used (typically <code>float</code> or
<code>double</code>, but maybe in some cases half precision or even quadruple precision
floats). An example class template is the following.</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#b48ead;">template </span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">int</span><span style="background-color:#eff1f5;color:#4f5b66;"> D, </span><span style="background-color:#eff1f5;color:#b48ead;">typename</span><span style="background-color:#eff1f5;color:#4f5b66;"> T&gt;
</span><span style="background-color:#eff1f5;color:#b48ead;">class </span><span style="background-color:#eff1f5;color:#d08770;">Tensor </span><span style="background-color:#eff1f5;color:#343d46;">{}</span><span style="background-color:#eff1f5;color:#4f5b66;">;
</span></pre>
<p>Generating bindings for these objects requires explicitly instantiating them for
all the values of <code>D</code> and <code>T</code> that you want to support. This will quickly become
cumbersome. Already for this single class, for a limited number of values for
<code>D</code> and <code>T</code>, the binding code becomes a mess:</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">1</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_1d_f</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">2</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_2d_f</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">3</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_3d_f</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">4</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_4d_f</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">5</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_5d_f</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">6</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_6d_f</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">1</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">double</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_1d_d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">2</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">double</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_2d_d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">3</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">double</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_3d_d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">4</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">double</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_4d_d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">5</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">double</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_5d_d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span><span style="background-color:#eff1f5;color:#4f5b66;">py::class_&lt;Tensor&lt;</span><span style="background-color:#eff1f5;color:#d08770;">6</span><span style="background-color:#eff1f5;color:#4f5b66;">, </span><span style="background-color:#eff1f5;color:#b48ead;">double</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;&gt;(m, &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_6d_d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;);
</span></pre><h2 id="metaprogramming-to-the-rescue">Metaprogramming to the rescue! {#metaprogramming-to-the-rescue}</h2>
<p>With <em>Boost.Hana</em>, it is possible to write concise and maintainable Python
bindings for both of these problematic cases. For the uninitiated:</p>
<blockquote>
<p>Hana is a header-only library for C++ metaprogramming suited for computations on
both types and values.</p>
</blockquote>
<p>... and computations on types seems to be exactly what we need.</p>
<h3 id="automatically-binding-user-defined-types-automatically-binding-user-defined-types">Automatically binding user-defined types {#automatically-binding-user-defined-types}</h3>
<p>First, let us focus on generating bindings to simple user-defined types. In
order to avoid listing the (types of the) fields when generating the bindings,
we need to be able to <em>inspect</em> our data types programmatically. This
<em>introspection</em> of user-defined types is supported by Boost.Hana using either
of two macro's.</p>
<p><code>BOOST_HANA_DEFINE_STRUCT</code> can be used within the original definition of a
struct, or <code>BOOST_HANA_ADAPT_STRUCT</code> can be used outside of the original
definition (if you cannot, or understandably do not want to touch the definition
of your data types). In our example, this would look like this:</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#b48ead;">struct </span><span style="background-color:#eff1f5;color:#4f5b66;">SomePacket {
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#b48ead;">static constexpr auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> desc = descriptor::some_packet;
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#bf616a;">BOOST_HANA_DEFINE_STRUCT</span><span style="background-color:#eff1f5;color:#4f5b66;">(SomePacket,
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">(int32_t, id),
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">, some_payload));
</span><span style="background-color:#eff1f5;color:#4f5b66;">}
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#b48ead;">struct </span><span style="background-color:#eff1f5;color:#4f5b66;">AnotherPacket {
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#b48ead;">static constexpr auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> desc = descriptor::another_packet;
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#bf616a;">BOOST_HANA_DEFINE_STRUCT</span><span style="background-color:#eff1f5;color:#4f5b66;">(AnotherPacket,
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">(int32_t, id),
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">(std::vector&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;, another_payload));
</span><span style="background-color:#eff1f5;color:#4f5b66;">}
</span></pre>
<p>Now, we have the possibility to loop over the members fields of our packets.
This can also simplify code in other places. For example, these network packets
have to be serialized, deserialized and measured for size. This can now all be
implemented in a function with a one-line body!</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#b48ead;">template </span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">typename</span><span style="background-color:#eff1f5;color:#4f5b66;"> Packet, </span><span style="background-color:#eff1f5;color:#b48ead;">typename</span><span style="background-color:#eff1f5;color:#4f5b66;"> Buffer&gt;
</span><span style="background-color:#eff1f5;color:#b48ead;">void </span><span style="background-color:#eff1f5;color:#8fa1b3;">fill</span><span style="background-color:#eff1f5;color:#4f5b66;">(Packet&amp; </span><span style="background-color:#eff1f5;color:#bf616a;">packet</span><span style="background-color:#eff1f5;color:#4f5b66;">, Buffer&amp; </span><span style="background-color:#eff1f5;color:#bf616a;">buffer</span><span style="background-color:#eff1f5;color:#4f5b66;">) {
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#bf616a;">hana::for_each</span><span style="background-color:#eff1f5;color:#4f5b66;">(packet, [&amp;](</span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> member) { buffer | </span><span style="background-color:#eff1f5;color:#bf616a;">hana::second</span><span style="background-color:#eff1f5;color:#4f5b66;">(member); });
</span><span style="background-color:#eff1f5;color:#4f5b66;">}
</span></pre>
<p>Here, <code>Buffer</code> is a class (<code>serializer</code>, <code>deserializer</code>, or a <code>scale</code>) that
implements <code>operator|</code> for all the possible field types. However, these
individual functions do not have to be implemented for each packet. With the
<code>for_each</code> function, we are able to loop over all <code>(name, value)</code> pairs for the
member fields of our packets.</p>
<p>Going back to the Python bindings, being able to loop over all member fields
means we no longer have to explicitly list constructors and accessors. We can
generate them automatically!</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#a7adba;">// 1) list packets and the names to give to their Python bindings
</span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> packets = </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">some_packet</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, hana::type_c&lt;SomePacket&gt;),
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">another_packet</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, hana::type_c&lt;AnotherPacket&gt;),
</span><span style="background-color:#eff1f5;color:#4f5b66;">  </span><span style="background-color:#eff1f5;color:#a7adba;">// ... many more
</span><span style="background-color:#eff1f5;color:#4f5b66;">);
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#8fa1b3;">hana::for_each</span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#bf616a;">packets</span><span style="background-color:#eff1f5;color:#4f5b66;">, [&amp;](</span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> x) {
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// 1) get C++ type (e.g. SomePacket)
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#b48ead;">using</span><span style="background-color:#eff1f5;color:#4f5b66;"> P = </span><span style="background-color:#eff1f5;color:#b48ead;">typename decltype</span><span style="background-color:#eff1f5;color:#4f5b66;">(+(x[</span><span style="background-color:#eff1f5;color:#d08770;">1_c</span><span style="background-color:#eff1f5;color:#4f5b66;">]))::type;
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// 2) get arguments for the constructor, as a tuple of types
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> types = </span><span style="background-color:#eff1f5;color:#bf616a;">hana::transform</span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#bf616a;">hana::members</span><span style="background-color:#eff1f5;color:#4f5b66;">(P{}), [](</span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> member) {
</span><span style="background-color:#eff1f5;color:#4f5b66;">            </span><span style="background-color:#eff1f5;color:#b48ead;">return</span><span style="background-color:#eff1f5;color:#4f5b66;"> hana::type_c&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">decltype</span><span style="background-color:#eff1f5;color:#4f5b66;">(member)&gt;;
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#4f5b66;">});
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// ... types is now e.g. (int32_t, float) for SomePacket
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// 3) we &#39;unpack&#39; this tuple inside py::init,
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#b48ead;">using</span><span style="background-color:#eff1f5;color:#4f5b66;"> Init = </span><span style="background-color:#eff1f5;color:#b48ead;">typename decltype</span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#bf616a;">hana::unpack</span><span style="background-color:#eff1f5;color:#4f5b66;">(
</span><span style="background-color:#eff1f5;color:#4f5b66;">            </span><span style="background-color:#eff1f5;color:#4f5b66;">types, hana::template_&lt;py::detail::initimpl::constructor&gt;))::type;
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// ... now Init is e.g py::init&lt;int32_t, float&gt;
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// 4) register class with Python
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> packet = py::</span><span style="background-color:#eff1f5;color:#bf616a;">class_</span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;P, Packet&gt;(m, x[</span><span style="background-color:#eff1f5;color:#d08770;">0_c</span><span style="background-color:#eff1f5;color:#4f5b66;">].</span><span style="background-color:#eff1f5;color:#bf616a;">c_str</span><span style="background-color:#eff1f5;color:#4f5b66;">()).</span><span style="background-color:#eff1f5;color:#bf616a;">def</span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#bf616a;">Init</span><span style="background-color:#eff1f5;color:#4f5b66;">());
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// ... x[0_c] contains the python name, e.g. some_packet, and Packet is
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// some base class.
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// 5) register accessors
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#bf616a;">hana::fold</span><span style="background-color:#eff1f5;color:#4f5b66;">(hana::</span><span style="background-color:#eff1f5;color:#bf616a;">accessors</span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;P&gt;(), </span><span style="background-color:#eff1f5;color:#bf616a;">std::ref</span><span style="background-color:#eff1f5;color:#4f5b66;">(packet),
</span><span style="background-color:#eff1f5;color:#4f5b66;">                   </span><span style="background-color:#eff1f5;color:#4f5b66;">[](py::class_&lt;P, Packet&gt;&amp; c,
</span><span style="background-color:#eff1f5;color:#4f5b66;">                      </span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> ka) -&gt; </span><span style="background-color:#eff1f5;color:#bf616a;">py</span><span style="background-color:#eff1f5;color:#4f5b66;">::</span><span style="background-color:#eff1f5;color:#bf616a;">class_</span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;P, Packet&gt;&amp; {
</span><span style="background-color:#eff1f5;color:#4f5b66;">                       </span><span style="background-color:#eff1f5;color:#b48ead;">return</span><span style="background-color:#eff1f5;color:#4f5b66;"> c.</span><span style="background-color:#eff1f5;color:#bf616a;">def</span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#bf616a;">hana::first</span><span style="background-color:#eff1f5;color:#4f5b66;">(ka).</span><span style="background-color:#eff1f5;color:#bf616a;">c_str</span><span style="background-color:#eff1f5;color:#4f5b66;">(), [&amp;ka](P&amp; p) {
</span><span style="background-color:#eff1f5;color:#4f5b66;">                           </span><span style="background-color:#eff1f5;color:#b48ead;">return </span><span style="background-color:#eff1f5;color:#bf616a;">hana::second</span><span style="background-color:#eff1f5;color:#4f5b66;">(ka)(p);
</span><span style="background-color:#eff1f5;color:#4f5b66;">                       </span><span style="background-color:#eff1f5;color:#4f5b66;">});
</span><span style="background-color:#eff1f5;color:#4f5b66;">                   </span><span style="background-color:#eff1f5;color:#4f5b66;">});
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// ... this may look complicated if you have not seen folds before, but
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// this is essentially iteratively calling .def on the registered packet
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// class. Note that we require the lambda indirection for pybind11 to
</span><span style="background-color:#eff1f5;color:#4f5b66;">        </span><span style="background-color:#eff1f5;color:#a7adba;">// recognize the member function.
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">});
</span></pre>
<p>Now, generating bindings for a new packet is completely automatic: we only have
to add it to the <code>packets</code> list. Also, when changing/adding/removing fields from
a packet, the Python bindings are updated automatically. Neat!</p>
<h3 id="automatically-instantiating-templates-automatically-instantiating-templates">Automatically instantiating templates {#automatically-instantiating-templates}</h3>
<p>We can also use Boost.Hana to generate combinations of <code>D</code> and <code>T</code> in our
<code>Tensor</code> example.</p>
<pre style="background-color:#eff1f5">
<span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> ds = </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">1d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, </span><span style="background-color:#eff1f5;color:#d08770;">1_c</span><span style="background-color:#eff1f5;color:#4f5b66;">), </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">2d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, </span><span style="background-color:#eff1f5;color:#d08770;">2_c</span><span style="background-color:#eff1f5;color:#4f5b66;">),
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">3d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, </span><span style="background-color:#eff1f5;color:#d08770;">3_c</span><span style="background-color:#eff1f5;color:#4f5b66;">), </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">4d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, </span><span style="background-color:#eff1f5;color:#d08770;">4_c</span><span style="background-color:#eff1f5;color:#4f5b66;">),
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">5d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, </span><span style="background-color:#eff1f5;color:#d08770;">5_c</span><span style="background-color:#eff1f5;color:#4f5b66;">), </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">6d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, </span><span style="background-color:#eff1f5;color:#d08770;">6_c</span><span style="background-color:#eff1f5;color:#4f5b66;">));
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> ts = </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">f</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, hana::type_c&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">float</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;),
</span><span style="background-color:#eff1f5;color:#4f5b66;">                           </span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(&quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">d</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s, hana::type_c&lt;</span><span style="background-color:#eff1f5;color:#b48ead;">double</span><span style="background-color:#eff1f5;color:#4f5b66;">&gt;));
</span><span style="background-color:#eff1f5;color:#4f5b66;">
</span><span style="background-color:#eff1f5;color:#8fa1b3;">hana::for_each</span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#bf616a;">hana::cartesian_product</span><span style="background-color:#eff1f5;color:#4f5b66;">(</span><span style="background-color:#eff1f5;color:#bf616a;">hana::make_tuple</span><span style="background-color:#eff1f5;color:#4f5b66;">(ds, ts)),
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">[&amp;](</span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> dt) {
</span><span style="background-color:#eff1f5;color:#4f5b66;">      </span><span style="background-color:#eff1f5;color:#b48ead;">const auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> d = dt[</span><span style="background-color:#eff1f5;color:#d08770;">0_c</span><span style="background-color:#eff1f5;color:#4f5b66;">][</span><span style="background-color:#eff1f5;color:#d08770;">1_c</span><span style="background-color:#eff1f5;color:#4f5b66;">];
</span><span style="background-color:#eff1f5;color:#4f5b66;">      </span><span style="background-color:#eff1f5;color:#b48ead;">using</span><span style="background-color:#eff1f5;color:#4f5b66;"> T = </span><span style="background-color:#eff1f5;color:#b48ead;">typename decltype</span><span style="background-color:#eff1f5;color:#4f5b66;">(+dt[</span><span style="background-color:#eff1f5;color:#d08770;">1_c</span><span style="background-color:#eff1f5;color:#4f5b66;">][</span><span style="background-color:#eff1f5;color:#d08770;">1_c</span><span style="background-color:#eff1f5;color:#4f5b66;">])::type;
</span><span style="background-color:#eff1f5;color:#4f5b66;">      </span><span style="background-color:#eff1f5;color:#b48ead;">auto</span><span style="background-color:#eff1f5;color:#4f5b66;"> name = &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">tensor_</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s + dt[</span><span style="background-color:#eff1f5;color:#d08770;">0_c</span><span style="background-color:#eff1f5;color:#4f5b66;">][</span><span style="background-color:#eff1f5;color:#d08770;">0_c</span><span style="background-color:#eff1f5;color:#4f5b66;">].</span><span style="background-color:#eff1f5;color:#bf616a;">c_str</span><span style="background-color:#eff1f5;color:#4f5b66;">() + &quot;</span><span style="background-color:#eff1f5;color:#a3be8c;">_</span><span style="background-color:#eff1f5;color:#4f5b66;">&quot;s +
</span><span style="background-color:#eff1f5;color:#4f5b66;">                  </span><span style="background-color:#eff1f5;color:#4f5b66;">dt[</span><span style="background-color:#eff1f5;color:#d08770;">1_c</span><span style="background-color:#eff1f5;color:#4f5b66;">][</span><span style="background-color:#eff1f5;color:#d08770;">0_c</span><span style="background-color:#eff1f5;color:#4f5b66;">].</span><span style="background-color:#eff1f5;color:#bf616a;">c_str</span><span style="background-color:#eff1f5;color:#4f5b66;">();
</span><span style="background-color:#eff1f5;color:#4f5b66;">      </span><span style="background-color:#eff1f5;color:#4f5b66;">py::</span><span style="background-color:#eff1f5;color:#bf616a;">class_</span><span style="background-color:#eff1f5;color:#4f5b66;">&lt;Tensor&lt;d, T&gt;&gt;(m, name.</span><span style="background-color:#eff1f5;color:#bf616a;">c_str</span><span style="background-color:#eff1f5;color:#4f5b66;">());
</span><span style="background-color:#eff1f5;color:#4f5b66;">    </span><span style="background-color:#eff1f5;color:#4f5b66;">});
</span></pre>
        </article>
    </section>
</div>

</div>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<script src="/livereload.js?port=1024&mindelay=10"></script></body>
</html>
